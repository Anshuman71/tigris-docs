import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";
import CodeBlock from "@theme/CodeBlock";
import { TSDataModels } from "@site/docs/templates/commons";
import {
  dataModelTabGroupId,
  decoratorModelLabel,
  interfaceModelLabel,
} from "@site/docs/sdkstools/typescript/commons";
import decoratorCollectionSource from "!!raw-loader!../_snippets/datamodel/collectionWithDecorator";
import interfaceCollectionSource from "!!raw-loader!../_snippets/datamodel/collectionWithInterface";
import decoratorCreateSource from "!!raw-loader!../_snippets/datamodel/createWithDecorator";
import interfaceCreateSource from "!!raw-loader!../_snippets/datamodel/createWithInterface";
import decoratorDropSource from "!!raw-loader!../_snippets/datamodel/dropWithDecorator";
import interfaceDropSource from "!!raw-loader!../_snippets/datamodel/dropWithInterface";
import decoratorListSource from "!!raw-loader!../_snippets/datamodel/listWithDecorator";
import interfaceListSource from "!!raw-loader!../_snippets/datamodel/listWithInterface";
import decoratorDropAllSource from "!!raw-loader!../_snippets/datamodel/dropAllWithDecorator";
import interfaceDropAllSource from "!!raw-loader!../_snippets/datamodel/dropAllWithInterface";
import decoratorEmbeddedSource from "!!raw-loader!../_snippets/datamodel/embeddedWithDecorator";
import interfaceEmbeddedSource from "!!raw-loader!../_snippets/datamodel/embeddedWithInterface";
import decoratorCompositeSource from "!!raw-loader!../_snippets/datamodel/compositeWithDecorator";
import interfaceCompositeSource from "!!raw-loader!../_snippets/datamodel/compositeWithInterface";
import decoratorArraySource from "!!raw-loader!../_snippets/datamodel/arrayWithDecorator";
import interfaceArraySource from "!!raw-loader!../_snippets/datamodel/arrayWithInterface";
import decoratorNestedArraySource from "!!raw-loader!../_snippets/datamodel/nestedArrayWithDecorator";
import interfaceNestedArraySource from "!!raw-loader!../_snippets/datamodel/nestedArrayWithInterface";

# Data Modeling

Tigris enables the data models to be declared as part of the application code.
These data models are then converted to appropriate objects, such as
collections, on the backend.

## Declaring Models

With the Tigris TypeScript client you can define your data models using
**Decorated class** or **declare-using-interface**.

<Tabs groupId={dataModelTabGroupId} queryString>
<TabItem value={decoratorModelLabel} label={decoratorModelLabel}>

Tigris client uses `@TigrisCollection("collection_name")` decorator on a class
to identify a `Collection` schema.

<CodeBlock language="ts">{decoratorCollectionSource}</CodeBlock>

Following decorators are available to annotate Class and its properties:

1. `@TigrisCollection()` - Annotates a class as Tigris Collection. Requires a
   `string` input as the name of Collection.

```ts
@TigrisCollection("catalog")
export class Catalog {}
```

2. `@PrimaryKey()` - Annotates a class propery as Collection's primary key. The
   data type is determined using "reflection" if the optional `type` parameter
   is not specified. More on primary key [here](#primary-key).

```ts
@TigrisCollection("catalog")
export class Catalog {
  @PrimaryKey({ order: 1, autogenerate: true })
  id?: number;

  @PrimaryKey(TigrisDataTypes.STRING, { order: 2 })
  name: string;
}
```

3. `Field()` - Annotates a class property as Collection's field. The data type
   is determined using "reflection" if the optional `type` parameter is not
   specified. A `@Field()` decorator accepts options to further describe the
   field.

```ts
@TigrisCollection("products")
export class Product {
  @PrimaryKey({ order: 1, autogenerate: true })
  id?: number;

  @PrimaryKey({ order: 2 })
  name: string;

  @Field({ default: 1 })
  quantity: number;

  @Field({ maxLength: 128, default: "" })
  description: string;
}
```

:::info

Properties not decorated with `@Field()` or `@PrimaryKey()` will be ignored in
schema. Hence, it is required that a class property be decorated to store it in
Collection.

:::

The
[Tigris TypeScript client repository](https://github.com/tigrisdata/tigris-client-ts/tree/main/src/__tests__/fixtures/schema)
has more examples for defining complex schemas.

## Embedded Data Model

Tigris offers rich documents that enable embedding related data in a single
document. Embedded models allow applications to complete database operations
with fewer queries or updates, thus reducing query activity and increasing
efficiency.

Below is an example of embedded data model. We first define the `ProductItem`
type and then embed it inside the `Order` type.

<CodeBlock language="ts">{decoratorEmbeddedSource}</CodeBlock>

## Arrays in documents

Including arrays in your schema requires `elements` option to identify type of
elements when using `@Field()` decorator.

<CodeBlock language="ts">{decoratorArraySource}</CodeBlock>

### Array of array(s)

When using classes to model your collection with nested arrays, additional
`depth` option is required in `@Field()` annotation. `depth` identifies the
depth of your nested array. E.g - field of type
`Array<Array<Array<Array<string>>>>` would have **depth = 4**.

<CodeBlock language="ts">{decoratorNestedArraySource}</CodeBlock>

</TabItem>

<TabItem value={interfaceModelLabel} label={interfaceModelLabel}>

If you prefer to not use class decorators you can define the collection schema
as follows:

<CodeBlock language="ts">{interfaceCollectionSource}</CodeBlock>

Essentially, schema is modeled as two parts:

1. Data containers - interface that holds the data model
2. Schema of Data containers - TigrisSchema definition of these data containers.

```ts
// data container
interface Catalog extends TigrisCollectionType {
  id?: string;
  name: string;
}

// schema definition
const catalogSchema: TigrisSchema<Catalog> = {
  id: {
    type: TigrisDataTypes.INT64,
    primary_key: {
      order: 1,
      autoGenerate: true,
    },
  },
  name: { type: TigrisDataTypes.STRING },
};
```

:::info

You must keep the data container and schema definition in sync.

:::

## Embedded Data Model

Tigris offers rich documents that enable embedding related data in a single
document. Embedded models allow applications to complete database operations
with fewer queries or updates, thus reducing query activity and increasing
efficiency.

Below is an example of embedded data model. We first define the `ProductItem`
type and then embed it inside the `Order` type.

<CodeBlock language="ts">{interfaceEmbeddedSource}</CodeBlock>

## Arrays in documents

Including arrays in your schema requires `items` attribute to identify its
contents.

<CodeBlock language="ts">{interfaceArraySource}</CodeBlock>

### Array of array(s)

Following example demonstrates a collection schema with nested arrays:

<CodeBlock language="ts">{interfaceNestedArraySource}</CodeBlock>

</TabItem>
</Tabs>

## Create a Collection

Creates a collection with the model and any new operation will see the changes.

<TSDataModels
  decoratorExample={decoratorCreateSource}
  interfaceExample={interfaceCreateSource}
/>

## Drop a Collection

Drops a collection with the model and any new operation will see the changes.

<TSDataModels
  decoratorExample={decoratorDropSource}
  interfaceExample={interfaceDropSource}
/>

## List Collections

Lists all the collections in the database.

<TSDataModels
  decoratorExample={decoratorListSource}
  interfaceExample={interfaceListSource}
/>

## Drop all Collections

Drops all collections in the database.

<TSDataModels
  decoratorExample={decoratorDropAllSource}
  interfaceExample={interfaceDropAllSource}
/>

## Primary Key {#primary - key}

A primary key uniquely identifies a document in the collection and enforces the
unique constraint. In the absence of a user-defined primary key, it is
auto-generated.

### Defining a Primary Key

The example above demonstrates how primary key is defined. The `order` attribute
in `primaryKey` represents the order of the field in the primary key. While
`autoGenerate: true` represents that the values for this field will be
automatically generated by the Tigris server.

### Composite Primary Key

Composite primary keys are also supported but in case of composite keys order of
the fields is important. The example below demonstrates how the order of the
fields are defined in case of a composite primary key

<TSDataModels
  decoratorExample={decoratorCompositeSource}
  interfaceExample={interfaceCompositeSource}
/>
```
