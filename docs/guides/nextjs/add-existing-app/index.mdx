---
title: Add Tigris to an existing Next.js Application
---

import {
  HomepageCard as Card,
  HomepageSection as Section,
} from "../../../../src/components/HomepageComponents";
import TerminalWindow from "@site/src/components/TerminalWindow/index";
import CodeBlock from "@theme/CodeBlock";
import createNextAppOutput from "!!raw-loader!./_createNextAppOutput";
import runDevOutput from "!!raw-loader!./_runDevOutput";
import loginOutput from "!!raw-loader!./_loginOutput";
import tigrisCreateAppOutput from "!!raw-loader!./_tigrisCreateAppOutput";
import Installation from "../../../includes/_install_cloud_login.mdx";

# Add Tigris to an existing Next.js Application

This guide discusses the concepts behind using Tigris in your existing Next.js project and configuring your application to integrate with Tigris.

![What will we build ouput](./ezgif.com-gif-maker.gif)

### Installation

<Installation />

Then, clone the Next.js blog-starter application:

```shell
npx create-next-app@latest --example blog-starter
```

```mdx-code-block
<TerminalWindow>
<CodeBlock language="shell">{createNextAppOutput}</CodeBlock>
</TerminalWindow>
```

This is a simple command to quickly start building a new Next.js application based off a template.
It may ask you a project name to download the project resources. We choose `my-nextjs-blog` as our
project name.

Change to `my-nextjs-blog` directory and install the dependencies:

```shell
cd my-nextjs-blog
npm install
```

Now, install the Tigris SDK:

```shell
npm install @tigrisdata/core@latest --save
```

### Setup Tigris account

Next, sign in to your existing Tigris account or signup for a new account:

```shell
tigris login
```

```mdx-code-block
<TerminalWindow>
<CodeBlock language="shell">{loginOutput}</CodeBlock>
</TerminalWindow>
```

### Add Tigris Cloud Credentials

For your application to connect with Tigris, you need to generate some credentials and
add them to the environment file.

```shell
tigris create application <YOUR_APP_NAME> "<YOUR_APP_DESCRIPTION>"
```

Replace `<YOUR_APP_NAME>` and `<YOUR_APP_DESCRIPTION>` arguments with your application's name and description, respectively. Then this will create the credentials and print them on the terminal screen:

```mdx-code-block
<TerminalWindow>
<CodeBlock language="shell">{tigrisCreateAppOutput}</CodeBlock>
</TerminalWindow>
```

You will use the `id` and `secret` from the output and add them as `TIGRIS_CLIENT_ID` and `TIGRIS_CLIENT_SECRET`
respectively in the file `.env.development.local` in your project.

Now, create a `.env.development.local` file in your project root directory and add the application credentials generated above to it:

```dotenv title=.env.development.local
TIGRIS_URI=api.preview.tigrisdata.cloud
TIGRIS_CLIENT_ID=client_id_here
TIGRIS_CLIENT_SECRET=client_secret_here
```

### Configure Tigris DB

Create a `tigris.ts` file in the `lib` folder to configure Tigris database for development and production:

```ts title=lib/tigris.ts
import { DB, Tigris } from "@tigrisdata/core";

const DB_NAME = "Comment";

declare global {
  // eslint-disable-next-line no-var
  var tigrisDb: DB;
}

let tigrisDb: DB;

// Caching the client because `next dev` would otherwise create a
// new connection on every file save while previous connection is active due to
// hot reloading. However, in production, Next.js would completely tear down before
// restarting, thus, disconnecting and reconnecting to Tigris.
if (process.env.NODE_ENV !== "production") {
  if (!global.tigrisDb) {
    const tigrisClient = new Tigris();
    global.tigrisDb = tigrisClient.getDatabase(DB_NAME);
  }
  tigrisDb = global.tigrisDb;
} else {
  const tigrisClient = new Tigris();
  tigrisDb = tigrisClient.getDatabase(DB_NAME);
}

// export to share DB across modules
export default tigrisDb;
```

### Define Models{#data-model}

Tigris stores data records as documents. Documents are analogous to JSON objects grouped in
a [Collection](/overview/databases). Tigris follows a convention of having models and schemas in `models/tigris` directory. Your model's structure should look like `models/tigris/<COLLECTION_NAME>.ts`

For example, create a `models/tigris/comments.ts` file in the project's root directory and add the code:

```ts title=models/tigris/comments.ts
import {
  TigrisCollectionType,
  TigrisDataTypes,
  TigrisSchema,
} from "@tigrisdata/core/dist/types";

export const COLLECTION_NAME = "comments";

export interface Comments extends TigrisCollectionType {
  id: number;
  name: string;
  content: string;
  date: string;
}

export const CommentsSchema: TigrisSchema<Comments> = {
  id: {
    type: TigrisDataTypes.INT32,
    primary_key: { order: 1, autoGenerate: true },
  },
  name: { type: TigrisDataTypes.STRING },
  content: { type: TigrisDataTypes.STRING },
  date: { type: TigrisDataTypes.DATE_TIME },
};
```

You've imported the Tigris `TigrisCollectionType` type, which is extended to define a model for your collections, the `TigrisDataTypes` type that gives you access to the Tigris data types, and the `TigrisSchema` which is used to define the schema for collections.

### Tigris Automatic schema management

Now let's set up Tigris automatic schema management, which will convert your data models to databases and collections. First, create the file `sripts/setup.ts` and add the following code:

```ts title=scripts/setup.ts
import { Tigris } from "@tigrisdata/core";
import { loadEnvConfig } from "@next/env";

// Run the config loader only when not executing within next runtime
if (process.env.NODE_ENV === undefined) {
  if (process.env.APP_ENV === "development") {
    loadEnvConfig(process.cwd(), true);
  } else if (process.env.APP_ENV === "production") {
    loadEnvConfig(process.cwd());
  }
}

async function main() {
  // setup client and register schemas
  const tigrisClient = new Tigris();
  await tigrisClient.registerSchemas("models/tigris");
}

main();
```

Here we used the `registerSchemas()` method, which accepts the path to the databases and collections that need to be created. Then you register all the collections in your `models/tigris` directory with
Tigris client that includes a `comment.ts` file with the `CommentsSchema` you defined.

Once the script runs, a database named `Comment` (as specified the in the `DB_NAME` variable in the `lib/tigris.ts` file) and a collection called `comments` (as defined in the `COLLECTION_NAME` variable in the `models/tigris/comment.ts` file) will be created, conforming to `CommentsSchema`. If the collection already exists, it will apply schema changes, if any, to that collection.

Next, automate this process by consistently executing the script at build time. Update your
`package.json` file with highlighted scripts:

```json title=package.json
  "scripts": {
    // highlight-next-line
    "predev": "APP_ENV=development npm run setup",
    "dev": "next dev",
    "build": "next build",
    // highlight-next-line
    "postbuild": "APP_ENV=production npm run setup",
    "start": "next start",
    "clean": "rm -rf node_modules .next",
    // highlight-next-line
    "setup": "npx ts-node scripts/setup.ts"
  }
```

You have added a `setup` command to run `scripts/setup.ts` and then added a `predev` hook to setup
schemas right before `dev` command is executed. Additionally, we added a `postbuild` hook to
set up schemas in the production environment right after `build`. Now, all your databases and
collections will sync with model definitions in the code.

:::tip No more schema management
You don't have to worry about applying schema changes anymore, managing schema is now a part of your
development workflow. Read more about this automated schema management [here](/typescript/documents/schema-bootstrap).
:::

### Create CRUD Operations

You can now create and execute CRUD operations against the `comments` collection. These
endpoints will be used by the client component of your application to perform CRUD operations in Tigris. Create an `api/comments/index.ts` file in the `pages` folder to
define your API endpoints.

#### ⌲ GET `/api/comments` to fetch all the comments.

```ts title=pages/api/comments/index.ts
import { NextApiRequest, NextApiResponse } from "next";
import { COLLECTION_NAME, Comments } from "../../../models/tigris/comment";
import tigrisDb from "../../../lib/tigris";

type Response = {
  result?: Array<Comments>;
  error?: string;
};

async function handleGet(req: NextApiRequest, res: NextApiResponse<Response>) {
  try {
    const commentsCollection =
      tigrisDb.getCollection<Comments>(COLLECTION_NAME);
    const cursor = commentsCollection.findMany();
    const comments = await cursor.toArray();
    res.status(200).json({ result: comments });
  } catch (err) {
    const error = err as Error;
    res.status(500).json({ error: error.message });
  }
}
```

Here we used a simple `findMany()` construct to read documents from a Tigris collection and returned
them as json.

#### ⌲ POST `/api/comments` to add new comment to the collection.

Now, create a `POST` method in `pages/api/comments/index.ts` create a new comment with the code:

```ts title=pages/api/comments/index.ts
//...
async function handlePost(req: NextApiRequest, res: NextApiResponse<Response>) {
  try {
    const comment = JSON.parse(req.body) as Comments;
    const commentsCollection =
      tigrisDb.getCollection<Comments>(COLLECTION_NAME);
    const inserted = await commentsCollection.insertOne(blog);
    res.status(200).json({ result: [inserted] });
  } catch (err) {
    const error = err as Error;
    res.status(500).json({ error: error.message });
  }
}
//...
```

Here we implemented a function that enables the user to insert a new comment into the collection using the `insertOne()` constructor.

Now add the `handler` function to define the routes for the API endpoints:

```ts title=pages/api/comments/index.ts
//...
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<Response>
) {
  switch (req.method) {
    case "GET":
      await handleGet(req, res);
      break;
    case "POST":
      await handlePost(req, res);
      break;
    default:
      res.setHeader("Allow", ["GET", "POST"]);
      res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}
//...
```

#### ⌲ GET `/api/comments/search` to find a comment matching the given query

The search endpoint will allow users to find comments in the collection. Let's add this endpoint that
accepts a query parameter and responds with matching results. Eg. GET `/api/comments/search?q="input query"`

Now create a `search.ts` file in the `pages/api/comments` folder and add the code:

```ts title=pages/api/comments/search.ts
import { NextApiRequest, NextApiResponse } from "next";
import { COLLECTION_NAME, Comments } from "../../../models/tigris/comment";
import { SearchRequest } from "@tigrisdata/core/dist/search/types";
import tigrisDb from "../../../lib/tigris";

type Data = {
  result?: Array<Comments>;
  error?: string;
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  const query = req.query["q"];
  if (query === undefined) {
    res.status(400).json({ error: "No search query found in request" });
    return;
  }
  try {
    const commentCollection = tigrisDb.getCollection<Comments>(COLLECTION_NAME);
    const searchRequest: SearchRequest<Comments> = { q: query as string };
    const searchResult = await commentCollection.search(searchRequest);
    const comment = new Array<Comments>();
    for (const hit of searchResult.hits) {
      comment.push(hit.document);
    }
    res.status(200).json({ result: comment });
  } catch (err) {
    const error = err as Error;
    res.status(500).json({ error: error.message });
  }
}
```

:::tip Built-in search
Tigris makes it really easy to implement [search](/typescript/documents/search) within your applications
by providing an embedded search engine that makes all your data instantly searchable.
:::

### Use in the Components

Now you can request the API to fetch and manipulate the data from your Tigris database in clients components.
First, create a `comment.tsx` and `each-comments.tsx` files in the `components` folder to create the components for the comments. Inside the `each-comments.tsx` file, add the code:

```tsx title=components/each-comments.tsx
import { Comments } from "../models/tigris/comment";

type Props = {
  comment: CommentType;
};
const EachComments = ({ comment }: Props) => {
  return (
    <div className="relative grid grid-cols-1 gap-4 p-4 mb-8 border rounded-lg bg-white shadow-lg">
      <div className="relative flex gap-4">
        <img
          src="https://icons.iconarchive.com/icons/diversity-avatars/avatars/256/charlie-chaplin-icon.png"
          className="relative rounded-lg -top-8 -mb-4 bg-white border h-20 w-20"
          alt=""
          loading="lazy"
        />
        <div className="flex flex-col w-full">
          <div className="flex flex-row justify-between">
            <p className="relative text-xl whitespace-nowrap truncate overflow-hidden">
              {comment.content}
            </p>
            <a className="text-gray-500 text-xl" href="#">
              <i className="fa-solid fa-trash"></i>
            </a>
          </div>
          <p className="text-gray-400 text-sm">ss{comment.date}</p>
        </div>
      </div>
      <p className="-mt-4 text-gray-500">{comment.name}.</p>
    </div>
  );
};

export default EachComments;
```

Next, add the code below to the `comment.tsx` file:

```tsx title=components/comment.tsx
import { useEffect, useState } from "react";
import { Comments } from "../models/tigris/comment";
import EachComments from "./each-comments";

const Comment = () => {
  const [comments, setComments] = useState<Comments[]>([]);
  const [isError, setIsError] = useState(false);

  const fetchComments = () => {
    fetch("/api/comments")
      .then((response) => response.json())
      .then((data) => {
        if (data.result) {
          setComments(data.result);
        } else {
          setIsError(true);
        }
      })
      .catch(() => {
        setIsError(true);
      });
  };

  useEffect(() => {
    fetchComments();
  }, []);
};

export default Comment;
```

Here we defined the React component that is rendered on the browser using the API endpoints we created in the previous section. The `fetchComments()` function renders the list by loading comments from `/api/comments` endpoint:

Similarly, create a `addComment()`, to create a new comment by sending a POST request to `/api/comments` endpoint:

```tsx title=components/comment.tsx
//...
const [nameInput, setNameInput] = useState("");
const [commentInput, setCommentInput] = useState("");

//...
const addComment = () => {
  fetch("/api/comments", {
    method: "POST",
    body: JSON.stringify({
      name: nameInput,
      content: commentInput,
      date: new Date().toJSON(),
    }),
  }).then(() => {
    setCommentInput("");
    setNameInput("");
    fetchComments();
  });
};
//...
```

Next, add a `searchQuery()` function to query the collection for a comments by sending a GET request to the `/api/comments/search` endpoint:

```tsx title=components/comment.tsx
//...
const [searchInput, setSearchInput] = useState("");

//...
const searchQuery = () => {
  console.log("dd");
  fetch(`/api/comments/search?q=${encodeURI(searchInput)}`, {
    method: "GET",
  })
    .then((response) => response.json())
    .then((data) => {
      if (data.result) {
        setComments(data.result);
      }
    });
};
//...
```

Then, render the comments and add the defined functions to their respective event handlers:

```tsx title=components/comment.tsx
//...
return (
  <div className="max-w-2xl mx-auto">
    <input
      className="border border-gray-300 text-gray-900 dark:text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5  dark:border-gray-600 dark:placeholder-gray-400  dark:focus:ring-blue-500 dark:focus:border-blue-500 mr-2 mb-6"
      placeholder="Search..."
      onChange={(e) => setSearchInput(e.target.value)}
      onKeyUp={searchQuery}
    />

    {comments.length ? (
      comments.map((comment) => (
        <EachComments comment={comment} key={comment.id} />
      ))
    ) : (
      <p className="relative grid grid-cols-1 gap-4 p-4 mb-8 border rounded-lg bg-white shadow-lg">
        No comments...
      </p>
    )}
    <h3>Leave a comment</h3>
    <div className="mb-6 mt-6">
      <input
        className="border border-gray-300 text-gray-900 dark:text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5  dark:border-gray-600 dark:placeholder-gray-400 dark:focus:ring-blue-500 dark:focus:border-blue-500"
        placeholder="Name:"
        onChange={(e) => setNameInput(e.target.value)}
        value={nameInput}
      />
    </div>
    <div className="mb-6 mt-6">
      <textarea
        className="border border-gray-300 text-gray-900 dark:text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5  dark:border-gray-600 dark:placeholder-gray-400 dark:focus:ring-blue-500 dark:focus:border-blue-500"
        placeholder="Say something..."
        onChange={(e) => setCommentInput(e.target.value)}
        value={commentInput}
      />
    </div>
    <button
      type="submit"
      className="bg-gray-600 hover:bg-gray-800 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm w-full sm:w-auto px-5 py-2.5 text-center mb-3"
      onClick={addComment}
    >
      Post comment
    </button>
    {isError && <p className="text-red-600">Something went wrong: {isError}</p>}
  </div>
);
//...
```

Lastly, render the `<Comment/>` component inside the `<Container>` component in the `posts/[slug].tsx` file:

```tsx title=posts/[slug].tsx
//...
import Comment from "../../components/comment"

//...
export default function Post({ ... }: ... {

  return (
  //...
   <Container>
     //...
     <Comment/>
   </Container>
   //...
  )
}
//...
```

<!-- MARKDOWN LINKS -->

[nextjs-url]: https://nextjs.org/
[tigris-todo-repo-url]: https://github.com/tigrisdata/tigris-vercel-starter
[tweet-intent]: https://twitter.com/intent/tweet?url=https%3A%2F%2Ftigrisdata.com%2Fnextjs%2F&text=I%20learned%20how%20easy%20it%20is%20to%20build%20%23data%20rich%20applications%20using%20@nextjs%20and%20@TigrisData
